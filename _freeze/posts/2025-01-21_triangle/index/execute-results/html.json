{
  "hash": "5c3a20cef1239a0f584cd9eb7ffcff30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"'as_triangle' - Wrapper Function\"\ndescription: |\n  In which I look at the 'as.triangle()' function from the {ChainLadder} package\ndate: \"2025-02-21\"\ncategories: [R, Reserving]\nimage: \"triangle.jpg\"\nimage-alt: \"A picture of a triangle\"\n---\n\n\n\nThe {ChainLadder} package is described as \"an R package providing methods and models which are typically used in insurance claims reserving\". I was recently tasked with moving our claims reserving models from excel to R, as our models are getting too big to handle (some of them are pushing 1GB). The {ChainLadder} package exposes functions that have been incredibly useful and time-saving for me during this exercise. These functions include, converting long data into wide data i.e triangle (more on this later), calculating development factors and \"predict\" functions for calculating ultimate claims reserves. To be honest, all I had to do was manipulate our claims data into a usable format for the {ChainLadder} suite of functions, plug the data through them and finally create outputs in excel summarizing the final reserves. \n\nThat being said, there are a few \"gotchas\" that I have encountered that I think are worth writing about. I also worked out some solutions that hopefully address some of these \"gotchas\". I discuss one of them here.\n\n## Quick Tutorial\n\nHistorical insurance data is typically represented in a triangle structure or wide format, showing the development of claims over time for each origin period. The triangle makes it easy to see the development of claims from one development period to another. As an example, we use data from the Reinsurance Association of America (RAA):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ChainLadder)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nRAA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 16181 18009 18608 18662 18834\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 16141 18735 22214 22863 23466    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 12935 15852    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n```\n\n\n:::\n:::\n\n\n\nFrom left to right, we can see the initial claim amount for all origin years under development \"dev\" period 1 and annual evaluations thereafter. A human could easily intuit the development of claims from this wide format. However, data is stored in a long format, where a variable has its own column and each row is an observation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename <-  file.path(system.file(\"Database\",\n                                   package=\"ChainLadder\"),\n                       \"TestData.csv\")\nmyData <- read.csv(filename)\nraa <- subset(myData, lob %in% \"RAA\")\nhead(raa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   origin dev value lob\n67   1981   1  5012 RAA\n68   1982   1   106 RAA\n69   1983   1  3410 RAA\n70   1984   1  5655 RAA\n71   1985   1  1092 RAA\n72   1986   1  1513 RAA\n```\n\n\n:::\n:::\n\n\n\nHow do we get from long to wide? {ChainLadder} provides a function for this called `as.triangle`, which converts data into a triangle format. Let's test this out:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraa.tri <- as.triangle(\n  Triangle = raa,\n  origin = \"origin\",\n  dev = \"dev\"\n)\n\nraa.tri\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1    2    3    4    5    6    7   8   9  10\n  1981 5012 3257 2638  898 1734 2642 1828 599  54 172\n  1982  106 4179 1111 5270 3116 1817 -103 673 535  NA\n  1983 3410 5582 4881 2268 2594 3479  649 603  NA  NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA  NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA  NA\n  1986 1513 4932 5257 1233 2917   NA   NA  NA  NA  NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA  NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA  NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA  NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA  NA\n```\n\n\n:::\n:::\n\n\n\nYou may have noticed that this is not the same triangle as what was shown above. This is because `RAA` is a cumulative triangle while `raa.tri` is an incremental triangle. We use `incr2cum` to turn an incremental triangle into a cumulative one:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraa.cum <- incr2cum(Triangle = raa.tri, na.rm = FALSE)\nraa.cum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 16181 18009 18608 18662 18834\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 16141 18735 22214 22863 23466    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 12935 15852    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n```\n\n\n:::\n:::\n\n\n\nPretty straight forward, I would say. In a perfect world, these functions are enough. Unfortunately, I don't leave in a perfect world. Let's put these functions through their paces.\n\n## The problem\n\n\n\n\n\n\n\nI have adjusted the RAA long data to have some gaps in the years and removed one development period at the end. This is how it looks like now:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raa <- as.triangle(\n  Triangle = raa.example\n)\n\nnew_raa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1    2    3    4    5    6    7   8   9\n  1981 5012 3257 2638  898 1734   NA   NA 599  54\n  1982  106 4179 1111 5270 3116 1817 -103 673 535\n  1983 3410 5582 4881   NA 2594 3479  649 603  NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA\n  1986 1513 4932 5257   NA   NA   NA   NA  NA  NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA\n```\n\n\n:::\n:::\n\n\n\nMake it into a cumulative triangle:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raa_cum <- incr2cum(new_raa)\nnew_raa_cum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1     2     3     4     5     6     7     8     9\n  1981 5012  8269 10907 11805 13539    NA    NA    NA    NA\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704\n  1983 3410  8992 13873    NA    NA    NA    NA    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA\n  1986 1513  6445 11702    NA    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA\n```\n\n\n:::\n:::\n\n\n\nYou may have noticed NAs in periods we have observations in for example dev 9 for 1981. We can fix this with the `na.rm` argument:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raa_cum <- incr2cum(new_raa, na.rm = TRUE)\nnew_raa_cum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1     2     3     4     5     6     7     8     9\n  1981 5012  8269 10907 11805 13539 13539 13539 14138 14192\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704\n  1983 3410  8992 13873 13873 16467 19946 20595 21198    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA\n  1986 1513  6445 11702 11702    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA\n```\n\n\n:::\n:::\n\n\n\nThis fixes some of the issues but there is one glaring problem left. This triangle is not really \"square\". Checking the diagonal, we can see a missing value where you would not expect to see one, i.e. for the development year 1986, dev period 5. You would expect that since there was no observation for that development period, the cumulative amount would be 11702, however, in its stead there is a missing value. \n\nWhy did this happen? This is because the `incr2cum` function assumes the triangle is half of a perfect square, where the number of development periods is equal to the number of origin periods. This assumption fails in a lot of cases. In particular, this assumption fails for long tail classes, where there are some development periods when no new claims are recorded for a while. Someone opened an [issue](https://github.com/mages/ChainLadder/issues/93) on the {ChainLadder} github page that does a good job of explaining this.\n\nThis is a problem because it breaks a lot of downstream functions that are essential in predicting the ultimate claims. I won't go into these downstream functions here but I will provide a potential solution for this.\n\n## The solution\n\nTo fix this, we can make a wrapper function; call it `as_triangle` that creates a skeleton of all unique origin periods, then creating development periods based on the length of the unique periods. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_triangle <- function(data, origin, dev, value) {\n  # create skeleton\n  unique_origins <- unique(data[[origin]]) # get unique origin periods\n  dev_period <- 1:(length(unique_origins)) # create development periods\n  triangle_skeleton <- expand.grid(unique_origins, dev_period, stringsAsFactors = FALSE)\n  names(triangle_skeleton) <- c(origin, dev)  \n\n  complete_skeleton <- merge(triangle_skeleton, data[, c(origin, dev, value)], by = c(origin, dev), all.x = TRUE)\n  incremental_triangle <- ChainLadder::as.triangle(\n    Triangle = complete_skeleton,\n    origin = origin,\n    dev = dev,\n    value = value\n  )\n\n  return(incremental_triangle)\n}\n```\n:::\n\n\n\nLet's test this out:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raa_fix <- as_triangle(data = raa.example, origin = \"origin\", dev = \"dev\", value = \"value\")\nnew_raa_fix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1    2    3    4    5    6    7   8   9 10\n  1981 5012 3257 2638  898 1734   NA   NA 599  54 NA\n  1982  106 4179 1111 5270 3116 1817 -103 673 535 NA\n  1983 3410 5582 4881   NA 2594 3479  649 603  NA NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA NA\n  1986 1513 4932 5257   NA   NA   NA   NA  NA  NA NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA NA\n```\n\n\n:::\n:::\n\n\n\nThe cumulative triangle will now be:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raa_fix_cum <- incr2cum(Triangle = new_raa_fix, na.rm = TRUE)\nnew_raa_fix_cum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 13539 13539 14138 14192 14192\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 13873 16467 19946 20595 21198    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 11702 11702    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n```\n\n\n:::\n:::\n\n\n\nThis is now a perfect square. There is a caveat to this function though; it assumes that the delay , i.e. the period between two development periods, is one. There are some triangles that are quarterly unlike the yearly example here, where development periods are labelled as 3, 9, 12... We can adjust the function further:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_triangle <- function(data, origin, dev, value, delay = 1, start = 1) {\n  # create skeleton\n  unique_origins <- unique(data[[origin]]) # get unique origin periods\n  dev_period <- seq(from = start, to = length(unique_origins), by = delay) # create development periods\n  triangle_skeleton <- expand.grid(unique_origins, dev_period, stringsAsFactors = FALSE)\n  names(triangle_skeleton) <- c(origin, dev)  \n\n  complete_skeleton <- merge(triangle_skeleton, data[, c(origin, dev, value)], by = c(origin, dev), all.x = TRUE)\n  incremental_triangle <- ChainLadder::as.triangle(\n    Triangle = complete_skeleton,\n    origin = origin,\n    dev = dev,\n    value = value\n  )\n\n  return(incremental_triangle)\n}\n```\n:::\n\n\n\nWith this, you need to know the delay beforehand. This is what I currently use for the IBNR exercise and I have not encountered any issues with it. However, don't take my word for it. You can find the function in this [github repository](https://github.com/michaelgicheru/as_triangle). You can adjust the function to suite your use case.\n\nIf you can think of any other solutions, please share!\n\n## Acknowledgements\n\nI would like to acknowledge the person who opened the github [issue](https://github.com/mages/ChainLadder/issues/93). They provide an excellent explanation of the problem and inspired the solution in this blog.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}