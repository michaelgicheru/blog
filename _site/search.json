[
  {
    "objectID": "services.html",
    "href": "services.html",
    "title": "Need my help?",
    "section": "",
    "text": "If you need help with automating internal business processes such as IFRS 17 reporting, general business reporting, analytics, package development or anything R, I can certainly help.\nI have experience in:\n\nMaking performant and reproducible R code for data analytics.\nAutomation of daily tasks such as report generation.\nDevelopment of internal R packages to make creating R scripts more reproducible and pushing the concept of DRY (Do not Repeat Yourself).\nAutomation of IFRS 17 reporting.\n\nThink I can help you with anything? Email me at michaelgicherumisc at gmail dot com. I should respond within a day."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Employment: Actuarial Associate @ Britam\nEducation: BBS Actuarial Science, Strathmore University (2023)\n\nHello there! I am Michael Gicheru, welcome to my blog. I’m a part-qualified actuary and music lover. I believe in all things open source. I believe in walkable cities. I have an irrational love for R, and are currently learning Rust.\nI have a Bachelor’s degree in Actuarial Science from Strathmore University. I am currently an Actuarial Associate at Britam, supporting the Non-Life subsidiary. My work includes calculating base estimate reserves, financial reporting, conducting experience reviews, pricing, asset-liability matching exercises and reinsurance reviews. I particularly enjoy automating my daily tasks in R.\nI try to talk about any interesting projects I have worked on or software I have stumbled upon on this blog; especially if it has a use case in actuarial science.\n\nContact Me\nIf you want to get in contact with me, please send me an email to michaelgicherumisc at gmail dot com."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A blog by Michael Gicheru",
    "section": "",
    "text": "‘as_triangle’ - Wrapper Function\n\n\n\nR\n\n\nReserving\n\n\n\nIn which I look at the ‘as.triangle()’ function from the {ChainLadder} package\n\n\n\nMichael Gicheru\n\n\nFeb 21, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello, world\n\n\n\nBlogging\n\n\n\nI have decided to start a blog, as a place to share and rant (sometimes) on stuff I care about. Here are some thoughts on what I want to achieve.\n\n\n\nMichael Gicheru\n\n\nDec 9, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024-12-09_why/index.html",
    "href": "posts/2024-12-09_why/index.html",
    "title": "Hello, world",
    "section": "",
    "text": "The time has come to create a personal blog, after some encouragement from my partner who thinks my views are worth sharing with the Internet (and who I suspect has grown tired of my occasional rants on code and work). I confess I have been interested in starting one given my love for reading blogs on #rstats, sports and business topics, among others. I finally got some time off work to finally start one.\nThat being said, I have a couple of goals with starting this blog:\n\nSharing code: I will be sharing code that I find interesting or useful, particularly packages or code that I come up with for work or my daily life. This will be mostly R and Rust code, relating to actuarial science and data science.\nCommunicating my philosophies: This includes but not limited to my thoughts on open source software, my love for walkable cities and occasionally, my belief that every human being deserves to be treated with kindness and sympathy, maybe even my faith. I think everyone should be able to air their views on the world or what they love, and the Internet is a wonderful tool for this. So this is me doing what I believe in.\nImproving my communication skills: This blog will be largely very technical. I am an actuary in my day job and most of my posts will revolve around this, and how I use R to do my work. I want to be able to communicate concepts and my thought processes as best as I can and hopefully improve on them.\nPushing the boundaries of R and recently Rust: I want to learn as much as I can about R and Rust and communicate what I learn with the actuarial and data science community. I want to see what use cases and potential these languages have, for communities I consider myself to be part of.\n\nYeah, that’s it, I think. In advance, thank you for reading."
  },
  {
    "objectID": "posts/2025-01-21_triangle/index.html",
    "href": "posts/2025-01-21_triangle/index.html",
    "title": "‘as_triangle’ - Wrapper Function",
    "section": "",
    "text": "The {ChainLadder} package is described as “an R package providing methods and models which are typically used in insurance claims reserving”. I was recently tasked with moving our claims reserving models from excel to R, as our models are getting too big to handle (some of them are pushing 1GB). The {ChainLadder} package exposes functions that have been incredibly useful and time-saving for me during this exercise. These functions include, converting long data into wide data i.e triangle (more on this later), calculating development factors and “predict” functions for calculating ultimate claims reserves. To be honest, all I had to do was manipulate our claims data into a usable format for the {ChainLadder} suite of functions, plug the data through them and finally create outputs in excel summarizing the final reserves.\nThat being said, there are a few “gotchas” that I have encountered that I think are worth writing about. I also worked out some solutions that hopefully address some of these “gotchas”. I discuss one of them here."
  },
  {
    "objectID": "posts/2025-01-21_triangle/index.html#quick-tutorial",
    "href": "posts/2025-01-21_triangle/index.html#quick-tutorial",
    "title": "‘as_triangle’ - Wrapper Function",
    "section": "Quick Tutorial",
    "text": "Quick Tutorial\nHistorical insurance data is typically represented in a triangle structure or wide format, showing the development of claims over time for each origin period. The triangle makes it easy to see the development of claims from one development period to another. As an example, we use data from the Reinsurance Association of America (RAA):\n\nlibrary(ChainLadder)\n\n\nRAA\n\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 16181 18009 18608 18662 18834\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 16141 18735 22214 22863 23466    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 12935 15852    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n\n\nFrom left to right, we can see the initial claim amount for all origin years under development “dev” period 1 and annual evaluations thereafter. A human could easily intuit the development of claims from this wide format. However, data is stored in a long format, where a variable has its own column and each row is an observation:\n\nfilename &lt;-  file.path(system.file(\"Database\",\n                                   package=\"ChainLadder\"),\n                       \"TestData.csv\")\nmyData &lt;- read.csv(filename)\nraa &lt;- subset(myData, lob %in% \"RAA\")\nhead(raa)\n\n   origin dev value lob\n67   1981   1  5012 RAA\n68   1982   1   106 RAA\n69   1983   1  3410 RAA\n70   1984   1  5655 RAA\n71   1985   1  1092 RAA\n72   1986   1  1513 RAA\n\n\nHow do we get from long to wide? {ChainLadder} provides a function for this called as.triangle, which converts data into a triangle format. Let’s test this out:\n\nraa.tri &lt;- as.triangle(\n  Triangle = raa,\n  origin = \"origin\",\n  dev = \"dev\"\n)\n\nraa.tri\n\n      dev\norigin    1    2    3    4    5    6    7   8   9  10\n  1981 5012 3257 2638  898 1734 2642 1828 599  54 172\n  1982  106 4179 1111 5270 3116 1817 -103 673 535  NA\n  1983 3410 5582 4881 2268 2594 3479  649 603  NA  NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA  NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA  NA\n  1986 1513 4932 5257 1233 2917   NA   NA  NA  NA  NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA  NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA  NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA  NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA  NA\n\n\nYou may have noticed that this is not the same triangle as what was shown above. This is because RAA is a cumulative triangle while raa.tri is an incremental triangle. We use incr2cum to turn an incremental triangle into a cumulative one:\n\nraa.cum &lt;- incr2cum(Triangle = raa.tri, na.rm = FALSE)\nraa.cum\n\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 16181 18009 18608 18662 18834\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 16141 18735 22214 22863 23466    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 12935 15852    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n\n\nPretty straight forward, I would say. In a perfect world, these functions are enough. Unfortunately, I don’t leave in a perfect world. Let’s put these functions through their paces."
  },
  {
    "objectID": "posts/2025-01-21_triangle/index.html#the-problem",
    "href": "posts/2025-01-21_triangle/index.html#the-problem",
    "title": "‘as_triangle’ - Wrapper Function",
    "section": "The problem",
    "text": "The problem\nI have adjusted the RAA long data to have some gaps in the years and removed one development period at the end. This is how it looks like now:\n\nnew_raa &lt;- as.triangle(\n  Triangle = raa.example\n)\n\nnew_raa\n\n      dev\norigin    1    2    3    4    5    6    7   8   9\n  1981 5012 3257 2638  898 1734   NA   NA 599  54\n  1982  106 4179 1111 5270 3116 1817 -103 673 535\n  1983 3410 5582 4881   NA 2594 3479  649 603  NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA\n  1986 1513 4932 5257   NA   NA   NA   NA  NA  NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA\n\n\nMake it into a cumulative triangle:\n\nnew_raa_cum &lt;- incr2cum(new_raa)\nnew_raa_cum\n\n      dev\norigin    1     2     3     4     5     6     7     8     9\n  1981 5012  8269 10907 11805 13539    NA    NA    NA    NA\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704\n  1983 3410  8992 13873    NA    NA    NA    NA    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA\n  1986 1513  6445 11702    NA    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA\n\n\nYou may have noticed NAs in periods we have observations in for example dev 9 for 1981. We can fix this with the na.rm argument:\n\nnew_raa_cum &lt;- incr2cum(new_raa, na.rm = TRUE)\nnew_raa_cum\n\n      dev\norigin    1     2     3     4     5     6     7     8     9\n  1981 5012  8269 10907 11805 13539 13539 13539 14138 14192\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704\n  1983 3410  8992 13873 13873 16467 19946 20595 21198    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA\n  1986 1513  6445 11702 11702    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA\n\n\nThis fixes some of the issues but there is one glaring problem left. This triangle is not really “square”. Checking the diagonal, we can see a missing value where you would not expect to see one, i.e. for the development year 1986, dev period 5. You would expect that since there was no observation for that development period, the cumulative amount would be 11702, however, in its stead there is a missing value.\nWhy did this happen? This is because the incr2cum function assumes the triangle is half of a perfect square, where the number of development periods is equal to the number of origin periods. This assumption fails in a lot of cases. In particular, this assumption fails for long tail classes, where there are some development periods when no new claims are recorded for a while. Someone opened an issue on the {ChainLadder} github page that does a good job of explaining this.\nThis is a problem because it breaks a lot of downstream functions that are essential in predicting the ultimate claims. I won’t go into these downstream functions here but I will provide a potential solution for this."
  },
  {
    "objectID": "posts/2025-01-21_triangle/index.html#the-solution",
    "href": "posts/2025-01-21_triangle/index.html#the-solution",
    "title": "‘as_triangle’ - Wrapper Function",
    "section": "The solution",
    "text": "The solution\nTo fix this, we can make a wrapper function; call it as_triangle that creates a skeleton of all unique origin periods, then creating development periods based on the length of the unique periods.\n\nas_triangle &lt;- function(data, origin, dev, value) {\n  # create skeleton\n  unique_origins &lt;- unique(data[[origin]]) # get unique origin periods\n  dev_period &lt;- 1:(length(unique_origins)) # create development periods\n  triangle_skeleton &lt;- expand.grid(unique_origins, dev_period, stringsAsFactors = FALSE)\n  names(triangle_skeleton) &lt;- c(origin, dev)  \n\n  complete_skeleton &lt;- merge(triangle_skeleton, data[, c(origin, dev, value)], by = c(origin, dev), all.x = TRUE)\n  incremental_triangle &lt;- ChainLadder::as.triangle(\n    Triangle = complete_skeleton,\n    origin = origin,\n    dev = dev,\n    value = value\n  )\n\n  return(incremental_triangle)\n}\n\nLet’s test this out:\n\nnew_raa_fix &lt;- as_triangle(data = raa.example, origin = \"origin\", dev = \"dev\", value = \"value\")\nnew_raa_fix\n\n      dev\norigin    1    2    3    4    5    6    7   8   9 10\n  1981 5012 3257 2638  898 1734   NA   NA 599  54 NA\n  1982  106 4179 1111 5270 3116 1817 -103 673 535 NA\n  1983 3410 5582 4881   NA 2594 3479  649 603  NA NA\n  1984 5655 5900 4211 5500 2159 2658  984  NA  NA NA\n  1985 1092 8473 6271 6333 3786  225   NA  NA  NA NA\n  1986 1513 4932 5257   NA   NA   NA   NA  NA  NA NA\n  1987  557 3463 6926 1368   NA   NA   NA  NA  NA NA\n  1988 1351 5596 6165   NA   NA   NA   NA  NA  NA NA\n  1989 3133 2262   NA   NA   NA   NA   NA  NA  NA NA\n  1990 2063   NA   NA   NA   NA   NA   NA  NA  NA NA\n\n\nThe cumulative triangle will now be:\n\nnew_raa_fix_cum &lt;- incr2cum(Triangle = new_raa_fix, na.rm = TRUE)\nnew_raa_fix_cum\n\n      dev\norigin    1     2     3     4     5     6     7     8     9    10\n  1981 5012  8269 10907 11805 13539 13539 13539 14138 14192 14192\n  1982  106  4285  5396 10666 13782 15599 15496 16169 16704    NA\n  1983 3410  8992 13873 13873 16467 19946 20595 21198    NA    NA\n  1984 5655 11555 15766 21266 23425 26083 27067    NA    NA    NA\n  1985 1092  9565 15836 22169 25955 26180    NA    NA    NA    NA\n  1986 1513  6445 11702 11702 11702    NA    NA    NA    NA    NA\n  1987  557  4020 10946 12314    NA    NA    NA    NA    NA    NA\n  1988 1351  6947 13112    NA    NA    NA    NA    NA    NA    NA\n  1989 3133  5395    NA    NA    NA    NA    NA    NA    NA    NA\n  1990 2063    NA    NA    NA    NA    NA    NA    NA    NA    NA\n\n\nThis is now a perfect square. There is a caveat to this function though; it assumes that the delay , i.e. the period between two development periods, is one. There are some triangles that are quarterly unlike the yearly example here, where development periods are labelled as 3, 9, 12… We can adjust the function further:\n\nas_triangle &lt;- function(data, origin, dev, value, delay = 1, start = 1) {\n  # create skeleton\n  unique_origins &lt;- unique(data[[origin]]) # get unique origin periods\n  dev_period &lt;- seq(from = start, to = length(unique_origins), by = delay) # create development periods\n  triangle_skeleton &lt;- expand.grid(unique_origins, dev_period, stringsAsFactors = FALSE)\n  names(triangle_skeleton) &lt;- c(origin, dev)  \n\n  complete_skeleton &lt;- merge(triangle_skeleton, data[, c(origin, dev, value)], by = c(origin, dev), all.x = TRUE)\n  incremental_triangle &lt;- ChainLadder::as.triangle(\n    Triangle = complete_skeleton,\n    origin = origin,\n    dev = dev,\n    value = value\n  )\n\n  return(incremental_triangle)\n}\n\nWith this, you need to know the delay beforehand. This is what I currently use for the IBNR exercise and I have not encountered any issues with it. However, don’t take my word for it. You can find the function in this github repository. You can adjust the function to suite your use case.\nIf you can think of any other solutions, please share!"
  },
  {
    "objectID": "posts/2025-01-21_triangle/index.html#acknowledgements",
    "href": "posts/2025-01-21_triangle/index.html#acknowledgements",
    "title": "‘as_triangle’ - Wrapper Function",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nI would like to acknowledge the person who opened the github issue. They provide an excellent explanation of the problem and inspired the solution in this blog."
  }
]